The author claims that some [[Programming Language]]s have multiple paradigm, though they focus on 2. 

The first one solves the specific problem that their [[Kernel Language]]'s [[Programming Paradigm]] is best at solving, the second one is complementary, for supporting [[Modularity]] and [[Abstraction]].

In this mindset, we can have $2^{n}$ combinations of concepts. Though the number of useful ones is far less than $2^{n}$, it is still way bigger than $n$.

# Examples

- Prolog
- Modeling Languages e.g. Comet
-  Solving libraries e.g. Gecode
-  Language embedding e.g. SQL